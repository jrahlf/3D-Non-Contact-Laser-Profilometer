/*
 * drive.cpp
 *
 *  Created on: Nov 20, 2013
 *      Author: jonas
 */

#include "drive.h"

GPIO__INPUT(M1_ENC_A, B, 4);
GPIO__INPUT(M1_ENC_B, B, 5);
GPIO__INPUT(M2_ENC_A, A, 8);
GPIO__INPUT(M2_ENC_B, A, 9);

GPIO__INPUT(Current_FB1, A, 2);
GPIO__INPUT(Current_FB2, A, 3);

GPIO__OUTPUT(M1_IN1, E, 2);
GPIO__OUTPUT(M1_IN2, E, 3);
GPIO__OUTPUT(M1_PWM, B, 4);//TIM3_CH1
GPIO__INPUT(M1_FS, C, 15);

GPIO__OUTPUT(M2_IN1, C, 10);
GPIO__OUTPUT(M2_IN2, C, 11);
GPIO__OUTPUT(M2_PWM, B, 5);//TIM3_CH2
GPIO__INPUT(M2_FS, C, 14);

using namespace xpcc::stm32;

namespace Motor {

volatile int encM1 = 0;
volatile int encM2 = 0;

void speedControll(int deltaX, int deltaY, int deltaTheta, int deltaT){

	float V_l, V_r;

	if(deltaTheta >= 0){
		V_r = 1;
		V_l = 1;
	} else {
		V_l = 1;
	}


}






void setPWMandDirection_M1(int pwm, Direction dir) {

	if (!M1_FS::read()) {
		//TODO error
	}

	switch (dir) {
	case FORWARD:
		M1_IN1::set(true);
		M1_IN2::set(false);
		break;
	case BACKWARD:
		M1_IN1::set(false);
		M1_IN2::set(true);
		break;
	case FREERUN:
		Timer3::setCompareValue(2, 0);
		return;
	case BREAK_HIGH:
		M1_IN1::set(true);
		M1_IN2::set(true);
		break;
	case BREAK_LOW:
		M1_IN1::set(false);
		M1_IN2::set(false);
		break;
	}
	Timer3::setCompareValue(1, pwm);
}

void setPWMandDirection_M2(int pwm, Direction dir) {

	if (!M2_FS::read()) {
		//TODO error
	}

	switch (dir) {
	case FORWARD:
		M2_IN1::set(true);
		M2_IN2::set(false);
		break;
	case BACKWARD:
		M2_IN1::set(false);
		M2_IN2::set(true);
		break;
	case FREERUN:
		Timer3::setCompareValue(2, 0);
		return;
	case BREAK_HIGH:
		M2_IN1::set(true);
		M2_IN2::set(true);
		break;
	case BREAK_LOW:
		M2_IN1::set(false);
		M2_IN2::set(false);
		break;
	}
	Timer3::setCompareValue(2, pwm);
}

void setPWM(double pwm, Motor motor, Direction dir) {
	assert_param(pwm >= 0);
	assert_param(pwm <= 1);

	int temp = 1200 * pwm;
	if (motor == Motor::MOTOR_1)
		setPWMandDirection_M1(temp, dir);
	else
		setPWMandDirection_M2(temp, dir);
}

void initMotor() {
//	Timer2::enable();
//	Timer2::setMode(Timer2::UP_COUNTER);
//
//	// 72 MHz / 2 / 2^16 ~ 550 Hz
//	Timer2::setPrescaler(2);
//	Timer2::setOverflow(65535);
//
//	Timer2::configureOutputChannel(2, Timer2::OUTPUT_PWM, 40000);
//	Timer2::applyAndReset();
//
//	Timer2::start();

	//M1_PWM::setAlternateFunction(AF_TIM3, PUSH_PULL, SPEED_100MHZ, FLOATING);
	//M2_PWM::setAlternateFunction(AF_TIM3, PUSH_PULL, SPEED_100MHZ, FLOATING);

	Timer3::enable();
	Timer3::setMode(Timer3::UP_COUNTER);
	Timer3::setPrescaler(1);
	Timer3::setOverflow(1200);
	Timer3::configureOutputChannel(1, Timer3::OUTPUT_PWM, 0);
	Timer3::configureOutputChannel(2, Timer3::OUTPUT_PWM, 0);
	Timer3::applyAndReset();
	Timer3::start();

}

void initCurrentSense() {

//	Adc1::setFreeRunningMode(true);
	//Adc1In::setAnalogInput();
//	Adc1::setChannel(Adc1::Channel::PinC0, Adc1::SampleTime::Cycles2);
//	Adc1::startConversion();

	Adc1::initialize();
	Adc1::enableFreeRunningMode();
	Adc1::setChannel(Adc1::Channels::PIN_A2, Adc1::SampleTime::CYCLES_240);
	Adc1::setChannel(Adc1::Channels::PIN_A3, Adc1::SampleTime::CYCLES_240);
	Adc1::startConversion();
}



volatile int getEnc1(){
	return encM1;
}
volatile int getEnc2(){
	return encM2;
}

extern "C" void
//EXTI15_10_IRQHandler(void)
EXTI4_IRQHandler(void) {
	if (xpcc::stm32::ExtInt::getInterruptFlag(ExtInt::Pin::PB4)) {
		if (M1_ENC_A::read()) { // steigende flanke
			if (M1_ENC_B::read()) { // --
				encM1--;
			} else { // ++
				encM1++;
			}
		} else {
			if (M1_ENC_B::read()) { // ++
				encM1++;
			} else { // --
				encM1--;
			}
		}
	}
	ExtInt::resetInterruptFlag(ExtInt::Pin::PB4);
}

extern "C" void
//EXTI15_10_IRQHandler(void)
EXTI9_5_IRQHandler(void) {
	if (ExtInt::getInterruptFlag(ExtInt::Pin::PA8)) {
		if (M2_ENC_A::read()) { // steigende flanke
			if (M2_ENC_B::read()) { // --
				encM2--;
			} else { // ++
				encM2++;
			}
		} else {
			if (M2_ENC_B::read()) { // ++
				encM2++;
			} else { // --
				encM2--;
			}
		}
	}
	ExtInt::resetInterruptFlag(ExtInt::Pin::PA8);
}

void initEncoder() {

	encM1 = encM2 = 0;

	//TODO Pull_Direction
	// Encoder Motor 1
	M1_ENC_A::setInput(xpcc::stm32::PULLUP);
	M1_ENC_B::setInput(xpcc::stm32::PULLUP);

	ExtInt::enable(ExtInt::Pin::PB4);
	ExtInt::setMode(ExtInt::Pin::PB4, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PB4);
	ExtInt::enableInterruptVector(ExtInt::Pin::PB4, 14);

	// Encoder Motor 2
	M2_ENC_A::setInput(xpcc::stm32::PULLUP);
	M2_ENC_B::setInput(xpcc::stm32::PULLUP);

	ExtInt::enable(ExtInt::Pin::PA8);
	ExtInt::setMode(ExtInt::Pin::PA8, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PA8);
	ExtInt::enableInterruptVector(ExtInt::Pin::PA8, 14);
}

}


