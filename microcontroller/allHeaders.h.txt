/*
 * atof.h
 *
 *  Created on: Jan 3, 2014
 *      Author: jonas
 */

#ifndef ATOF_H_
#define ATOF_H_

/**
 * Takes a pointer to a string and converts the
 * first number found into an int and returns it
 * If the number is a fractional number, it is expected to
 * have exactly 2 decimal digits. The value is multiplied by
 * 1000 prior returning it
 *
 * @param p pointer to string
 * @param stopPosition position where parsing was stopped due to non numerical character
 * 				this is a pointer to the original string and can be reused to parse several arguments
 * 				0 can be passed if position is not needed
 * @return Integer of string, if fractional 1000 times the value
 */
int atoi2(const char *p, const char** stopPosition);

/**
 * Same as atoi2(const char *p), but scans by at most maxLen characters
 * @param p pointer to string
 * @param maxLen
 * @param errorValue value which is returned if no number is found
 * @return Integer of string, or errorValue
 */
int atoi2(const char *p, const int maxLen, const int errorValue);

/**
 * @param p pointer to string
 * @param maxLen
 * @param errorValue value which is returned if no number is found
 * @return float of string, or errorValue
 */
float atof2(const char *p, const int maxLen, const float errorValue);



#endif /* ATOF_H_ */
/*
 * commandHandlers.h
 *
 *  Created on: Jan 23, 2014
 *      Author: jonas
 */

#ifndef COMMANDHANDLERS_H_
#define COMMANDHANDLERS_H_



#include <xpcc/architecture.hpp>
#include "project.h"
#include "control.h"
#include "atof.h"
#include "limits.h"
#include "transform.h"
#include "motor.h"
#include "laserInterface.h"
#include "Trigger.h"
#include "../ext/stm32f4xx_lib/CMSIS/Device/ST/STM32F4xx/Include/stm32f4xx.h"
#include "utils.h"
#include "pattern.h"
#include "rectangle.h"


struct Handlers{

template<Axis axis>
static bool gotoHandler(const char* cmd, int length){
	int pos = atoi2(cmd, length, INT_MAX);
	if(pos == INT_MAX){
		return false;
	}
	Utils::startLoggingControl();
	pos = Transform::mmToEncoder(pos);
	Control<ALL>::enablePositionControl(true);
	Control<axis>::setShallPosition(pos);
	dout << axis << " going go " << pos << endl;
	return true;
}

template<Axis axis>
static bool setSpeedHandler(const char* cmd, int length){
	float speed = atof2(cmd, length, 2.f);
	if(speed == 2.f){
		cerr << "speed param must be between -1 and 1" << endl;
		return false;
	}
	Utils::startLoggingControl();
	Control<ALL>::enablePositionControl(false);
	Control<ALL>::enableSpeedControl(true);
	Control<axis>::setShallSpeed(speed);
	dout << axis << " set speed to " << speed << endl;
	return true;
}

static bool setMaxSpeedHandler(const char* cmd, int length){
	float speed = atof2(cmd, length, 2.f);
	if(speed == 2.f){
		cerr << "speed param must be between 0 and 1" << endl;
		return false;
	}
	Control<ALL>::setMaxSpeed(speed);
	dout << " set speed to " << speed << endl;
	return true;
}

template<Axis axis>
static bool setPwmHandler(const char* cmd, int length){
	int speed = atoi2(cmd, length, INT_MAX);
	if(speed == INT_MAX){
		return false;
	}
	xpcc::stm32::SysTickTimer::enable();
	xpcc::delay_ms(5);
	if(speed > 1200){
		speed = 1200;
	}else if(speed < -1200){
		speed = -1200;
	}
	Control<ALL>::enablePositionControl(false);
	Control<ALL>::enableSpeedControl(false);
	Motor<axis>::setSpeed(speed);
	dout << axis << " set pwm to " << speed << endl;
	return true;
}

static bool enableSystickHandler(const char* cmd, int length){
	(void) cmd;
	(void) length;
	bool enable = atoi2(cmd, 1, 1);
	if(enable){
		Utils::enableSystick();
	}else{
		Utils::disableSystick();
	}
	dout << "systick enable " << enable << endl;
	return true;
}

static bool enableTrigger(const char* cmd, int length){
	(void) cmd;
	(void) length;
	bool param = atoi2(cmd, 1, 2);
	Trigger::enable(param);
	dout << "trigger enable " << param << endl;
	return true;
}

static bool getLaserError(const char* cmd, int length){
	(void) cmd;
	(void) length;
	iout << "Laser error: " << Laser::getLastError() << endl;
	return false;
}

static bool resetHandler(const char* cmd, int length){
	(void) cmd;
	(void) length;
	NVIC_SystemReset();
	return false;
}

static bool pausePatternHandler(const char* cmd, int length){
	(void) cmd;
	(void) length;
	Pattern::done();
	return false;
}

static bool rectanglePatternHandler(const char* cmd, int length){
	//expected: 4 arguments: x, y, width, height
	static int lastx=-1, lasty=-1, lastw=-1, lasth=-1;

	const char* currentPos;
	int x = atoi2(cmd, &currentPos);
	int y = atoi2(currentPos, &currentPos);
	int width = atoi2(currentPos, &currentPos);
	int height = atoi2(currentPos, &currentPos);
	int samplingResolution = atoi2(currentPos, &currentPos);

	//sanity checks:
	if(currentPos - cmd > length){
		cerr << "buffer overrun " << (currentPos - cmd) << endl;
		return false;
	}
	if(x > 40 || x < 0){
		iout << "x param is out of bounds: " << x << endl;
		return false;
	}
	if(y > 40 || y < 0){
		iout << "y param is out of bounds: " << y << endl;
		return false;
	}
	if(x+width > 40 || width <= 0){
		iout << "(x+)width param is out of bounds: " << (x+width) << endl;
		return false;
	}
	if(y+height > 40 || height <= 0){
		iout << "(y+)height param is out of bounds: " << height << endl;
		return false;
	}
	if(samplingResolution <= 0 || samplingResolution > 100000){
		iout << "sampling resolution param is out of bounds: " << samplingResolution << endl;
		return false;
	}

	dout << "rectangle: (x,y,width,height) " << x << ", " << y << ", " << width << ", " << height << endl;

	if(Pattern::isRunning()){
		iout << "Previous pattern is still running!" << endl;
		return false;
	}

	if(x == lastx && y == lasty && width == lastw && height == lasth){
		//execute pattern
		Trigger::enable(true);
		RectangleZigZag zRect;
		zRect.configure(x, y, width, height, samplingResolution);
		Pattern::setPattern(zRect);
		Pattern::start();
		return true;
	}

	lastx = x;
	lasty = y;
	lastw = width;
	lasth = height;

	//demonstrate pattern outline
	Trigger::enable(true);
	Rectangle rect;
	rect.configure(x, y, width, height);
	Pattern::setPattern(rect);
	Pattern::start();

	return true;
}

};

#endif /* COMMANDHANDLERS_H_ */
/*
 * control.h
 *
 *  Created on: Nov 24, 2013
 *      Author: jonas
 */

#ifndef CONTROL_H_
#define CONTROL_H_

#include "project.h"
#include <xpcc/math/filter/pid.hpp>


template<Axis axis>
class Control{

	friend class Control<ALL>;

private:
	static volatile int pos_shall;
	static volatile int v_is; // velocity in pulses/s
	static volatile int v_shall;

	static xpcc::Pid<float, 1> v_pid;
	static xpcc::Pid<float, 1> pos_pid;
	static int v_u; // speed controller output
	static int v_ureal;
	static int last_pos; //position when the last control loop was executed

	static bool positionControlEnabled;
	static bool speedControlEnabled;

public:

	static bool init();
	static void enablePositionControl(bool enable);
	static void enableSpeedControl(bool enable);
	static void setShallPosition(int x);
	/**
	 * Also disables the position controller
	 * @param speed [-1,1]
	 */
	static void setShallSpeed(double speed);
	static int getSpeedErrorSum();
	static int getPositionErrorSum();
	static int32_t getIsPosition();
	static inline int getShallSpeed(){ return v_shall; }
	static inline int getIsSpeed(){ return v_is; }
	static inline int getShallPosition(){ return pos_shall; }
	static inline int getSpeedU(){ return v_u; }
	static inline int getSpeedRealU(){ return v_ureal; }
	static inline int getPosU(){ return v_shall; } //only valid if position controller is active
	static const xpcc::Pid<float,1>::Parameter& getVPidParams(){ return v_pid.getParameter(); }
	static const xpcc::Pid<float,1>::Parameter& getPosPidParams(){ return pos_pid.getParameter(); }
	static void resetVPid();
	static void resetPosPid();
	/**
	 * [0, 1]
	 * Limits the output of the position controller
	 */
	static void setMaxSpeed(float maxSpeed);

	/**
	 * To be called periodically (1kHz)
	 * Computes new ouput values for the H-bridge
	 */
	static void update(bool externalLimitation);

};

template<Axis axis> volatile int Control<axis>::pos_shall;
template<Axis axis> volatile int Control<axis>::v_is;
template<Axis axis> volatile int Control<axis>::v_shall;
template<Axis axis> int Control<axis>::v_u;
template<Axis axis> int Control<axis>::v_ureal;

template<Axis axis> bool Control<axis>::positionControlEnabled;
template<Axis axis> bool Control<axis>::speedControlEnabled;

template<Axis axis> xpcc::Pid<float, 1> Control<axis>::v_pid;
template<Axis axis> xpcc::Pid<float, 1> Control<axis>::pos_pid;
template<Axis axis> int Control<axis>::last_pos; //position when the last control loop was executed

template<> void Control<ALL>::update(bool externalLimitation);
template<> int32_t Control<X>::getIsPosition();
template<> int32_t Control<Y>::getIsPosition();
template<> bool Control<ALL>::init();

#include "control_impl.h"


#endif /* CONTROL_H_ */
/*
 * control.cpp
 *
 *  Created on: Nov 25, 2013
 *      Author: jonas
 */


#include "project.h"
#include "control.h"
#include "motor.h"
#include "hallSensor.h"
#include "securityController.h"

template<Axis axis>
class Motor;


template<Axis axis>
bool Control<axis>::init(){
	Control<axis>::v_is = 0;
	Control<axis>::v_shall = 0;
	Control<axis>::last_pos = 0;
	Control<axis>::positionControlEnabled = true;
	Control<axis>::speedControlEnabled = true;
	//param order: P, I, D, maxErrorSum, maxOutput
	Control<axis>::pos_pid = xpcc::Pid<float, 1>(CONTROLX_KP, CONTROLX_KI, CONTROLX_KD,
			CONTROLX_MAX_ERRORSUM, CONTROLX_MAX_OUTPUT);
	Control<axis>::v_pid = xpcc::Pid<float, 1>(CONTROLV_KP, CONTROLV_KI, CONTROLV_KD,
			CONTROLV_MAX_ERRORSUM, CONTROLV_MAX_OUTPUT);
	return true;
}


template<Axis axis>
void Control<axis>::update(bool externalLimitation){
	int enc = getIsPosition();

	if(positionControlEnabled){
		pos_pid.update(pos_shall - enc, externalLimitation);
		v_shall = pos_pid.getValue();
	}

	v_is = (enc - last_pos)*CONTROL_FREQUENCY;
	last_pos = enc;

	if(speedControlEnabled){
		v_pid.update(v_shall - v_is);
		v_u = v_pid.getValue();
		v_ureal = v_u;
		SecurityController<axis>::saturate(v_ureal);
		Motor<axis>::setSpeed(v_ureal);
	}
}

template<Axis axis>
void Control<axis>::setShallPosition(int position){
	pos_shall = position;
}

//max speed is 5500rpm*400 counts/rev
template<Axis axis>
void Control<axis>::setShallSpeed(double speed){
	//disable position control
	Control<ALL>::enablePositionControl(false);
	if(speed > 1)
		speed = 1;
	if(speed < -1)
		speed = -1;
	v_shall = speed*MOTOR_MAX_SPEED;
}

template<Axis axis>
int Control<axis>::getSpeedErrorSum(){
	return v_pid.getErrorSum();
}

template<Axis axis>
int Control<axis>::getPositionErrorSum(){
	return pos_pid.getErrorSum();
}









/*
 * encoder.h
 *
 *  Created on: Nov 26, 2013
 *      Author: jonas
 */

#ifndef ENCODER_H_
#define ENCODER_H_

#include <xpcc/architecture.hpp>

namespace Encoder{

/**
 * Initializes Timer 2 and Timer 5 to be used to decode quadrature
 * encoder signal in 4x decoding
 * @return
 */
bool init();

/**
 * Zeros the internal encoder values
 */
void zero();

/**
 *
 */
void pause();

void start();

};


#endif /* ENCODER_H_ */
/*
 * hallSensor.h
 *
 *  Created on: Dec 23, 2013
 *      Author: jonas
 */

#ifndef HALLSENSOR_H_
#define HALLSENSOR_H_

#pragma GCC push_options
#pragma GCC optimize ("O0")

#include "project.h"
#include "control.h"

template<Axis axis>
class HallSensor{
private:
	static volatile bool triggered[2];
	static volatile bool state[2]; //the real current state
	static volatile int triggeredPosition[2];

public:
	static bool init();

	static volatile bool isAtFront(){
		return triggered[0];
	}

	static volatile bool isAtEnd(){
		return triggered[1];
	}

	static void clearFrontSensor(){
		triggered[0] = false;
	}

	static void clearEndSensor(){
		triggered[1] = false;
	}

	//get the real states
	static bool getFrontState(){
		return state[0];
	}

	static bool getEndState(){
		return state[1];
	}

	//set real state, called by interrupt routine
	//if new state is false, triggered will be set too

	static void setFrontState(bool newState){
		state[0] = newState;
		newState = !newState;
		triggered[0] |= newState;
		if(newState)
			triggeredPosition[0] = Control<axis>::getIsPosition();
	}

	static void setEndState(bool newState){
		state[1] = newState;
		newState = !newState;
		triggered[1] |= newState;
		if(newState)
			triggeredPosition[1] = Control<axis>::getIsPosition();
	}

	/**
	 * If the trigger is set and the axis has been moved
	 * by at least HALLSENSOR_HYSTERESIS, the trigger is unset
	 * @return returns true, if trigger is unset
	 */
	static bool checkFrontState();

	/**
	 * If the trigger is set and the axis has been moved
	 * by at least HALLSENSOR_HYSTERESIS, the trigger is unset
	 * @return true, if trigger is unset
	 */
	static bool checkEndState();

};

template<Axis axis> volatile bool HallSensor<axis>::triggered[2];
template<Axis axis> volatile bool HallSensor<axis>::state[2];
template<Axis axis> volatile int HallSensor<axis>::triggeredPosition[2];

template<> bool HallSensor<ALL>::init();

#include "hallSensor_impl.h"

#pragma GCC pop_options
#endif /* HALLSENSOR_H_ */
/*
 * hallSensor_impl.h
 *
 *  Created on: Jan 1, 2014
 *      Author: jonas
 */

#ifndef HALLSENSOR_IMPL_H_
#define HALLSENSOR_IMPL_H_

#include "project.h"

template<Axis axis>
bool HallSensor<axis>::checkFrontState(){
	//coutRaw << "a " << Control<axis>::getIsPosition() - triggeredPosition[0] << endl;
	if(Control<axis>::getIsPosition() - triggeredPosition[0] > HALLSENSOR_HYSTERESIS){
		triggered[0] = false;
		return true;
	}
	return false;
}

template<Axis axis>
bool HallSensor<axis>::checkEndState(){
	//coutRaw << "b " << Control<axis>::getIsPosition() - triggeredPosition[0] << endl;
	if(Control<axis>::getIsPosition() - triggeredPosition[1] < -HALLSENSOR_HYSTERESIS){
		triggered[1] = false;
		return true;
	}
	return false;
}


#endif /* HALLSENSOR_IMPL_H_ */
/*
 * laserInterface.h
 *
 *  Created on: Dec 30, 2013
 *      Author: jonas
 */

#ifndef LASERINTERFACE_H_
#define LASERINTERFACE_H_

#include "project.h"

class Laser{
public:

	class DoubleBuffer{
	public:
		static unsigned char buf1[LASER_INPUT_BUFFER_SIZE+1];
		static unsigned char buf2[LASER_INPUT_BUFFER_SIZE+1];
		//swap pointers instead of copying
		static unsigned char* bufInPtr;
		static unsigned char* bufOutPtr;
		static int inSize;
		static int outSize;

	public:

		static inline int getInSize(){
			return inSize;
		}

		static inline void addChar(unsigned char c){
			bufInPtr[inSize] = c;
			inSize++;
		}

		static inline unsigned char* inPtr(){
			return bufInPtr;
		}

		static inline unsigned char* outPtr(){
			return bufOutPtr;
		}

		/**
		 * Returns outPtr as an integer
		 * @return the current measurement in nm
		 */
		static int asInt();

		/**
		 * Also resets input buffer and adds trailing
		 * null byte to new output buffer
		 */
		static inline void swap(){
			unsigned char* temp = bufInPtr;
			bufInPtr = bufOutPtr;
			bufOutPtr = temp;
			bufOutPtr[inSize] = '\0';
			outSize = inSize;
			inSize = 0;
		}

		static inline void reset(){
			inSize = 0;
		}

		static char* get(){
			return (char*)bufOutPtr;
		}

		static int good();
	};

public:
	static bool init();
	static int getLastError();
	static void enableRequests();
};

#endif /* LASERINTERFACE_H_ */
/*
 * motor.h
 *
 *  Created on: Nov 24, 2013
 *      Author: jonas
 */

#ifndef MOTOR_H_
#define MOTOR_H_

#include "project.h"
#include "control.h"

template<Axis axis>
class Motor {

friend class Control<axis>;
friend class Motor<ALL>;

public:
	static bool init();

	struct Ext{
		/**
		 * Brakes the motor
		 */
		static void brake();

		/**
		 * Lets the motor run freely
		 */
		static void freeRun();
	};

friend class Motor<axis>::Ext;
friend class PC;

	static bool getFaultStatus();

public:
	//These functions shall be only called by a Controller

	/**
	 * Set the current speed
	 * @param speed in the range of [-1200,1200]
	 */
	static void setSpeed(int speed);

	/**
	 * Brakes the motor
	 */
	static void brake();

	/**
	 * Lets the motor run freely
	 */
	static void freeRun();




};


#endif /* MOTOR_H_ */
/*
 * pattern.h
 *
 *  Created on: Jan 18, 2014
 *      Author: jonas
 */

#ifndef PATTERN_H_
#define PATTERN_H_

#include "control.h"
#include "project.h"
#include "state.h"

class Pattern{
	static void (*func)(void);
	static int running;
public:
	template<class T>
	static void setPattern(T pattern, float maxSpeed = 1){
		Control<ALL>::setMaxSpeed(maxSpeed);
		func = &T::sample;
	}
	static void follow(){
		if(!running || func == 0){
			return;
		}
		func();
	}
	static void pause(){
		running = false;
	}
	static void start(){
		running = true;
		State::set(State::SCANNING_RECTANGLE);
	}
	static void done(){
		running = 0;
		State::set(State::READY);
	}
	static int isRunning(){
		return running;
	}
};



#endif /* PATTERN_H_ */
/*
 * pcInterface.h
 *
 *  Created on: Dec 30, 2013
 *      Author: jonas
 */

#ifndef PCINTERFACE_H_
#define PCINTERFACE_H_

#include "atof.h"

#include <xpcc/architecture.hpp>
#include "project.h"
#include "commandHandlers.h"

extern xpcc::stm32::BufferedUsart2 uart;

static const bool ENABLE_STREAMS = false;

class PC{
public:
	/**
	 * Setup UART for communication
	 * Should be the first init function to call
	 * @return
	 */
	static bool init();
	static void scanForCommands();
	static void registerCommandHandler(const char* command, bool (*handler)(const char*, int));

	struct Command {
	    const char* name;
	    bool (*handler)(const char*, int); //if true is returned, "ok - command" is printed on uart
	};

	static bool defaultHandler(const char*, int);
	static Command* getCommand(const char* command);
};

/**
 * Wrapper class to provide various streams
 */
template<char prefix, bool useChecksum, bool enable = ENABLE_STREAMS, int TEXT_BUFFER_SIZE = 60>
class Stream{
private:
	static char text[TEXT_BUFFER_SIZE];
	static int pos;
public:
	static void flush();
	static void writeMeasurement(char* measurement, int length);
	static void write(char c);
	static bool read(char &c){ (void)c; return false;}
	static bool read(uint8_t &c){ (void)c; return false;}
private:
	static void calcChecksum();
};

template<char prefix, bool useChecksum, bool enable, int TEXT_BUFFER_SIZE>
char Stream<prefix, useChecksum, enable, TEXT_BUFFER_SIZE>::text[TEXT_BUFFER_SIZE];

template<char prefix, bool useChecksum, bool enable, int TEXT_BUFFER_SIZE>
int Stream<prefix, useChecksum, enable, TEXT_BUFFER_SIZE>::pos;



template<char prefix, bool useChecksum, bool enable, int TEXT_BUFFER_SIZE>
void Stream<prefix, useChecksum, enable, TEXT_BUFFER_SIZE>::write(char c){
	if(!enable){
		return;
	}
	if(prefix != 'M'){
		if(pos == TEXT_BUFFER_SIZE-3){
			text[pos] = c;
			text[pos+1] = '\n';
			text[pos+2] = '\0';
			flush();
			return;
		}
		text[pos++] = c;
		if(c == '\n'){
			text[pos++] = '\0';
			flush();
		}
	}else{ //zero overhead version for measurement
		//text[pos++] = c;
		uart.write(c);
	}
}

template<char prefix, bool useChecksum, bool enable, int TEXT_BUFFER_SIZE>
void Stream<prefix, useChecksum, enable, TEXT_BUFFER_SIZE>::flush(){
	if(!enable){
		return;
	}

	uart.write(prefix);
	if(useChecksum){
		uart.write('X'); //X for checksum
	}
	uart.write(',');

	const char* ptr = &text[0];
	const char* end = &text[pos];

	while(ptr != end){
		uart.write(*ptr);
		ptr++;
	}

	if(useChecksum){
		calcChecksum();
	}

	pos = 0;
}

#endif /* PCINTERFACE_H_ */
/*
 * project.h
 *
 *  Created on: Dec 29, 2013
 *      Author: jonas
 */

#ifndef PROJECT_H_
#define PROJECT_H_

#include <xpcc/architecture.hpp>

enum Axis{
	X = 0,
	Y = 2,
	Z = 4, //unused
	ALL
};

/**
 * position-out, similar to mout, but only contains position data
 * Prefix character: P
 */
extern xpcc::IOStream pout;
/**
 * measurement-out, for sending measurement data to computer
 * Prefix character: M
 * Raw stream like coutRaw, to reduce latency and prevent inconsistency
 * between position and measurement
 */
extern xpcc::IOStream mout;
/**
 * debug-out, for printing debug statements
 * should be disabled for final software
 * Prefix character: D
 */
extern xpcc::IOStream dout;
/**
 * for error logging
 * Prefix character: E
 */
extern xpcc::IOStream cerr;
/**
 * INFO-out, for printing important informations
 * and for printing requested values (e.g. getLaserError)
 * Prefix character: I
 */
extern xpcc::IOStream iout;
/**
 * for debugging, no prefix
 * Not to be used with final software
 */
extern xpcc::IOStream coutRaw;
#define endl '\n'

// --------------------------------------------------------------------
// Motor related constants
// --------------------------------------------------------------------
const int MOTOR_RPM = 5500;
const int MOTOR_ENC_PER_REV = 400;
const int MOTOR_GEAR_RATIO = 5;
//datasheet: 36666
//experimental: 49000
const int MOTOR_MAX_SPEED = 49000; //encoder counts per second
#define MOTOR_MAX_VOLTAGE 12


// --------------------------------------------------------------------
// CONTROL RELATED CONSTANTS
// CONTROLX refers to position control
// --------------------------------------------------------------------
#define CONTROL_FREQUENCY 1000
const float CONTROLV_KP = 0.02f;
const float CONTROLV_KI = 0.5f;
const float CONTROLV_KD = 0;
const float CONTROLV_MAX_OUTPUT = 1200;
const float CONTROLV_MAX_ERRORSUM = MOTOR_MAX_SPEED/10;

const float CONTROLX_KP = 5.0f;
const float CONTROLX_KI = 0.1f;
const float CONTROLX_KD = 0.2f;
const float CONTROLX_MAX_OUTPUT = MOTOR_MAX_SPEED;
const float CONTROLX_MAX_ERRORSUM = MOTOR_ENC_PER_REV*10;


// --------------------------------------------------------------------
// Security controller related constants
// --------------------------------------------------------------------
#define HALLSENSOR_HYSTERESIS 5000

// --------------------------------------------------------------------
// Laser interface related constants
// --------------------------------------------------------------------
#define LASER_INPUT_BUFFER_SIZE 50
#define INVALID_MEASUREMENT_STRING "9000"

#endif /* PROJECT_H_ */
/*
 * rectangle.h
 *
 *  Created on: Feb 1, 2014
 *      Author: jonas
 */

#ifndef RECTANGLE_H_
#define RECTANGLE_H_

#include "pattern.h"

class Rectangle{
private:
	static int x, y, width, height;

public:
	/**
	 * Units in mm
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 */
	static void configure(int x, int y, int width, int height);
	static void sample();
};



#endif /* RECTANGLE_H_ */
/*
 * RectangleZigZag.h
 *
 *  Created on: Jan 18, 2014
 *      Author: jonas
 */

#ifndef RECTANGLEZIGZAG_H_
#define RECTANGLEZIGZAG_H_

#include "pattern.h"

class RectangleZigZag{
private:
	static int startX, stopX, startY, stopY;
	static int samplingResolution;

	static bool isAtEnd();
public:
	/**
	 * Size in encoder counts
	 * @param width
	 * @param height
	 */
	static void configure(int x, int y, int width, int height, int samplingResolution);
	static void sample();
};

#endif /* RECTANGLEZIGZAG_H_ */
/*
 * securityController.h
 *
 *  Created on: Dec 28, 2013
 *      Author: jonas
 */

#ifndef SECURITYCONTROLLER_H_
#define SECURITYCONTROLLER_H_

#include "project.h"
#include "hallSensor.h"
#include "state.h"

template <Axis axis> class HallSensor;

template<Axis axis>
class SecurityController{
public:

	template<typename T>
	static void saturate(T& value){
		if(HallSensor<axis>::isAtEnd() && value > 0){
			value = 0;
			bool clear = HallSensor<axis>::checkEndState();
			State::setSecondaryState(State::MOTOR_LIMITED, !clear);
		}else if(HallSensor<axis>::isAtFront() && value < 0){
			value = 0;
			bool clear = HallSensor<axis>::checkFrontState();
			State::setSecondaryState(State::MOTOR_LIMITED, !clear);
		}
	}
};


#endif /* SECURITYCONTROLLER_H_ */
/*
 * state.h
 *
 *  Created on: Dec 30, 2013
 *      Author: jonas
 */

#ifndef STATE_H_
#define STATE_H_

class State{
public:

	static const int INITIALIZING = 0x0;
	static const int READY = 0x1;
	static const int MOTOR_LIMITED = 0x1<<1;
	static const int SCANNING_RECTANGLE = 0x1<<2;

	static const int PC_INIT_FAIL = 0x1<<3;
	static const int MOTOR1_FAULT = 0x1<<4;
	static const int MOTOR2_FAULT = 0x1<<5;

	/**
	 * This should be the very first function call
	 * after setting up the cpu frequency
	 */
	static void init();

	/**
	 *
	 * @return the current state
	 */
	static int get(){
		return currentState;
	}

	/**
	 * Sets the new state
	 * @param newState the new state
	 * TODO send message to PC in case of errors
	 */
	static void set(int newState);
	static void setSecondaryState(int state, bool set);
	static void setGreen(bool on);
	static void setRed(bool on);
	static void setBlue(bool on);
	static void setOrange(bool on);

private:
	static int currentState;
};


#endif /* STATE_H_ */
/*
 * transform.h
 *
 *  Created on: Jan 23, 2014
 *      Author: jonas
 */

#ifndef TRANSFORM_H_
#define TRANSFORM_H_

#include "project.h"

struct Transform{
	static int mmToEncoder(int mm){
		return MOTOR_ENC_PER_REV*MOTOR_GEAR_RATIO*mm;
	}
};



#endif /* TRANSFORM_H_ */
/*
 * Trigger.h
 *
 *  Created on: Jan 16, 2014
 *      Author: jonas
 */

#ifndef TRIGGER_H_
#define TRIGGER_H_

/**
 * Used in conjunction with the laser and sends the current
 * measurement + position if the stage moved by a certain threshold
 */
class Trigger {
private:
public:
	/**
	 * Should be called from main loop at
	 */
	static void sample();
	/**
	 * Sets a new threshold
	 * @param threshold
	 */
	static void setThreshold(int threshold);
	/**
	 * Enable or disables triggering
	 * @param enable
	 */
	static void enable(bool enable);
	/**
	 * If disabled, only the position will be output
	 * @param enable
	 */
	static void enableMeasurementOutput(bool enable);

};


#endif /* TRIGGER_H_ */
/*
 * utils.h
 *
 *  Created on: Feb 1, 2014
 *      Author: jonas
 */

#ifndef UTILS_H_
#define UTILS_H_

namespace Utils{
	void enableSystick();
	void disableSystick();
	void startLoggingControl();
	/**
	 * Drives to position (0,0), that is the most left and most lower
	 * position of the stage, when viewed from the top
	 * When that position is reached, the current position is set to 0
	 * To be called at startup
	 */
	void calibrateZero();
};



#endif /* UTILS_H_ */
