/*
 * atof.c
 *
 *  Created on: Jan 3, 2014
 *      Author: jonas
 */


#include "atof.h"

//
// Simple and fast atof (ascii to float) function.
//
// - Executes about 5x faster than standard MSCRT library atof().
// - An attractive alternative if the number of calls is in the millions.
// - Assumes input is a proper integer, fraction, or scientific format.
// - Matches library atof() to 15 digits (except at extreme exponents).
// - Follows atof() precedent of essentially no error checking.
//
// 09-May-2009 Tom Van Baak (tvb) www.LeapSecond.com
//

/**
* source: http://www.leapsecond.com/tools/fast_atof.c
* Modified by: Jonas Rahlf
*
* see atof.h for documentation
*/

#define white_space(c) ((c) == ' ' || (c) == '\t')
#define valid_digit(c) ((c) >= '0' && (c) <= '9')
#define valid_char(c) (((c) >= '0' && (c) <= '9') || c == '+' || c == '-')
int atoi2 (const char *p, const char** stopPosition){
    int sign = 0;
    int value = 0;
    const char* const start = p;

    // Skip leading garbage

    while (!valid_char(*p) ) {
    	if(p == '\0'){
    		goto exit;
    	}
        p += 1;
    }

    // Get sign, if any.

    sign = 1.0;
    if (*p == '-') {
        sign = -1.0;
        p += 1;

    } else if (*p == '+') {
        p += 1;
    }

    //skip leading zeros
    /*while(*p == '0')
    	p++;*/

    // Get digits before decimal point or exponent, if any.

    for (value = 0.0; valid_digit(*p); p += 1){
        value = value * 10.0 + (*p - '0');
    }

    if (*p == '.'){
    	p++;
		for (; valid_digit(*p); p += 1){
			value = value * 10.0 + (*p - '0');
		}
		value *= 10;
    }

    // Get digits after decimal point, if any.

    /*if (*p == '.') {
        double pow10 = 10.0;
        p += 1;
        while (valid_digit(*p)) {
            value += (*p - '0') / pow10;
            pow10 *= 10.0;
            p += 1;
        }
    }*/

    // Return signed and scaled floating point result.
    exit: ;
    if(stopPosition != 0){
    	*stopPosition = p;
    }
    return sign * value;
}

int atoi2 (const char *p, const int maxLen, const int garbage){
    int sign;
    int value;
    const char* pEnd = p+maxLen;

    // Skip leading garbage
    if(p == pEnd){
    	return garbage;
    }

    while (!valid_char(*p) ) {
        p += 1;
        if(p == pEnd){
        	return garbage;
        }
    }

    // Get sign, if any.

    sign = 1.0;
    if (*p == '-') {
        sign = -1.0;
        p += 1;

    } else if (*p == '+') {
        p += 1;
    }

    if(p == pEnd){
		return garbage;
	}

    //skip leading zeros
    while(*p == '0'){
    	p++;
    	if(p == pEnd){
			return 0; //not garbage
		}
    }

    // Get digits before decimal point or exponent, if any.

    for (value = 0.0; valid_digit(*p); p += 1){
    	if(p == pEnd){
			return sign * value;
		}
        value = value * 10.0 + (*p - '0');

    }

    if (*p == '.'){
    	p++;
		for (; valid_digit(*p); p += 1){
			if(p == pEnd){
				return sign * value;
			}
			value = value * 10.0 + (*p - '0');
		}
		value *= 10;
    }

    // Get digits after decimal point, if any.

    /*if (*p == '.') {
        double pow10 = 10.0;
        p += 1;
        while (valid_digit(*p)) {
            value += (*p - '0') / pow10;
            pow10 *= 10.0;
            p += 1;
        }
    }*/

    // Return signed and scaled floating point result.

    return sign * value;
}

float atof2 (const char *p, const int maxLen, const float garbage){
    int sign;
    float value;
    const char* pEnd = p+maxLen;

    // Skip leading garbage
    if(p == pEnd){
    	return garbage;
    }

    while (!valid_char(*p) ) {
        p += 1;
        if(p == pEnd){
        	return garbage;
        }
    }

    // Get sign, if any.

    sign = 1.0;
    if (*p == '-') {
        sign = -1.0;
        p += 1;

    } else if (*p == '+') {
        p += 1;
    }

    if(p == pEnd){
		return garbage;
	}

    //skip leading zeros
    while(*p == '0'){
    	p++;
    	if(p == pEnd){
			return 0;
		}
    }

    // Get digits before decimal point or exponent, if any.

    for (value = 0.0; valid_digit(*p); p += 1){
    	if(p == pEnd){
			return sign * value;
		}
        value = value * 10.0 + (*p - '0');
    }

    // Get digits after decimal point, if any.

    if (*p == '.') {
        double pow10 = 10.0;
        p += 1;
        if(p == pEnd){
			return sign * value;
		}
        while (valid_digit(*p)) {
            value += (*p - '0') / pow10;
            pow10 *= 10.0;
            p += 1;
            if(p == pEnd){
				return sign * value;
			}
        }
    }

    // Return signed and scaled floating point result.

    return sign * value;
}

/*
 * control.cpp
 *
 *  Created on: Dec 29, 2013
 *      Author: jonas
 */

#include "control.h"

template<>
bool Control<ALL>::init(){
	return Control<X>::init() && Control<Y>::init();
}

template<>
void Control<ALL>::update(bool externalLimitation){
	Control<X>::update(externalLimitation);
	Control<Y>::update(externalLimitation);
}

template<>
int32_t Control<X>::getIsPosition(){
	return int32_t(xpcc::stm32::Timer2::getValue());
}

template<>
int32_t Control<Y>::getIsPosition(){
	return int32_t(xpcc::stm32::Timer5::getValue());
}

template<>
void Control<ALL>::resetVPid(){
	Control<X>::v_pid.reset();
	Control<Y>::v_pid.reset();
}

template<>
void Control<ALL>::resetPosPid(){
	Control<X>::pos_pid.reset();
	Control<Y>::pos_pid.reset();
}

template<>
void Control<ALL>::enableSpeedControl(bool enable){
	Control<ALL>::resetVPid();
	Control<X>::speedControlEnabled = enable;
	Control<Y>::speedControlEnabled = enable;
}

template<>
void Control<ALL>::enablePositionControl(bool enable){
	Control<X>::positionControlEnabled = enable;
	Control<Y>::positionControlEnabled = enable;
	if(enable){
		Control<ALL>::enableSpeedControl(true);
	}
	Control<ALL>::resetPosPid();
}

template<>
void Control<ALL>::setMaxSpeed(float maxSpeed){
	if(maxSpeed > 1)
		maxSpeed = 1;
	if(maxSpeed < 0)
		maxSpeed = 0;
	int speed = MOTOR_MAX_SPEED*maxSpeed;
	Control<X>::pos_pid.setMaxOutput(speed);
	Control<Y>::pos_pid.setMaxOutput(speed);
}


/*
 * encoder.cpp
 *
 *  Created on: Nov 26, 2013
 *      Author: jonas
 */


#include "encoder.h"
#include "control.h"
#include <xpcc/architecture.hpp>
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/misc.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h"
#include "../ext/stm32f4xx_lib/CMSIS/Device/ST/STM32F4xx/Include/stm32f4xx.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h"

using namespace xpcc::stm32;

/*
 * xpcc does not support timer pin remap
 * Source: http://www.micromouseonline.com/2013/02/16/quadrature-encoders-with-the-stm32f4/
 * definitions for the quadrature encoder pins
 */
// Left Motor Channels
#define ENCLA_PIN               GPIO_Pin_15
#define ENCLA_GPIO_PORT         GPIOA
#define ENCLA_GPIO_CLK          RCC_AHB1Periph_GPIOA
#define ENCLA_SOURCE            GPIO_PinSource15
#define ENCLA_AF                GPIO_AF_TIM2

#define ENCLB_PIN               GPIO_Pin_3
#define ENCLB_GPIO_PORT         GPIOB
#define ENCLB_GPIO_CLK          RCC_AHB1Periph_GPIOB
#define ENCLB_SOURCE            GPIO_PinSource3
#define ENCLB_AF                GPIO_AF_TIM2

// Right Motor Channels
#define ENCRA_PIN               GPIO_Pin_0
#define ENCRA_GPIO_PORT         GPIOA
#define ENCRA_GPIO_CLK          RCC_AHB1Periph_GPIOA
#define ENCRA_SOURCE            GPIO_PinSource0
#define ENCRA_AF                GPIO_AF_TIM5

#define ENCRB_PIN               GPIO_Pin_1
#define ENCRB_GPIO_PORT         GPIOA
#define ENCRB_GPIO_CLK          RCC_AHB1Periph_GPIOA
#define ENCRB_SOURCE            GPIO_PinSource1
#define ENCRB_AF                GPIO_AF_TIM5

// determine the timers to use
#define ENCL_TIMER              TIM2
#define ENCL_TIMER_CLK          RCC_APB1Periph_TIM2
#define ENCR_TIMER              TIM5
#define ENCR_TIMER_CLK          RCC_APB1Periph_TIM5

#define LEFT_COUNT()            ENCL_TIMER->CNT
#define RIGHT_COUNT()           ENCR_TIMER->CNT

namespace Encoder{

void encodersInit();

bool init(){
	encodersInit();
	Encoder::zero();
	return true;
}


/*
 * Configure two timers as quadrature encoder counters.
 * Details of which timers should be used are
 * in the project hardware header file.
 * Most timers can be used if channels 1 and 2 are available on pins.
 * The timers are mostly 16 bit. Timers can be set to 32 bit but they are
 * not very convenient for IO pins so the counters are simply set to to
 * 16 bit counting regardless.
 * A mouse needs 32 bits of positional data and, since it also needs the
 * current speed, distance is not maintained by the encoder code but will
 * be looked after by the motion control code.
 * The counters are set to X4 mode. The only alternative is X2 counting.
 */
void encodersInit (void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  // turn on the clocks for each of the ports needed
  RCC_AHB1PeriphClockCmd (ENCLA_GPIO_CLK, ENABLE);
  RCC_AHB1PeriphClockCmd (ENCLB_GPIO_CLK, ENABLE);
  RCC_AHB1PeriphClockCmd (ENCRA_GPIO_CLK, ENABLE);
  RCC_AHB1PeriphClockCmd (ENCRB_GPIO_CLK, ENABLE);

  // now configure the pins themselves
  // they are all going to be inputs with pullups
  GPIO_StructInit (&GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Pin = ENCLA_PIN;
  GPIO_Init (ENCLA_GPIO_PORT, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = ENCLB_PIN;
  GPIO_Init (ENCLB_GPIO_PORT, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = ENCRA_PIN;
  GPIO_Init (ENCRA_GPIO_PORT, &GPIO_InitStructure);
  GPIO_InitStructure.GPIO_Pin = ENCRB_PIN;
  GPIO_Init (ENCRB_GPIO_PORT, &GPIO_InitStructure);

  // Connect the pins to their Alternate Functions
  GPIO_PinAFConfig (ENCLA_GPIO_PORT, ENCLA_SOURCE, ENCLA_AF);
  GPIO_PinAFConfig (ENCLB_GPIO_PORT, ENCLB_SOURCE, ENCLB_AF);
  GPIO_PinAFConfig (ENCRA_GPIO_PORT, ENCRA_SOURCE, ENCRA_AF);
  GPIO_PinAFConfig (ENCRB_GPIO_PORT, ENCRB_SOURCE, ENCRB_AF);

  // Timer peripheral clock enable
  RCC_APB1PeriphClockCmd (ENCL_TIMER_CLK, ENABLE);
  RCC_APB1PeriphClockCmd (ENCR_TIMER_CLK, ENABLE);

  // set them up as encoder inputs
  // set both inputs to rising polarity to let it use both edges
  TIM_EncoderInterfaceConfig (ENCL_TIMER, TIM_EncoderMode_TI12,
                              TIM_ICPolarity_Rising,
                              TIM_ICPolarity_Rising);
  TIM_SetAutoreload (ENCL_TIMER, 4294967295);
  TIM_EncoderInterfaceConfig (ENCR_TIMER, TIM_EncoderMode_TI12,
                              TIM_ICPolarity_Rising,
                              TIM_ICPolarity_Rising);
  TIM_SetAutoreload (ENCR_TIMER, 4294967295);

  // turn on the timer/counters
  TIM_Cmd (ENCL_TIMER, ENABLE);
  TIM_Cmd (ENCR_TIMER, ENABLE);

}

void zero(){
	Timer2::setValue(0);
	Timer5::setValue(0);
}

};

/*
 * faultHandlers.cpp
 *
 *  Created on: Jan 2, 2014
 *      Author: jonas
 */



#include <xpcc/architecture.hpp>
#include "project.h"
#include "state.h"

GPIO__OUTPUT(ledRed, D, 14);
GPIO__OUTPUT(ledBlue, D, 15);
GPIO__OUTPUT(ledOrange, D, 13);
GPIO__OUTPUT(ledGreen, D, 12);

static void blink(){
	ledRed::setOutput(xpcc::stm32::PUSH_PULL);
	ledBlue::setOutput(xpcc::stm32::PUSH_PULL);
	ledOrange::setOutput(xpcc::stm32::PUSH_PULL);
	ledGreen::setOutput(xpcc::stm32::PUSH_PULL);
	while(true){
		ledRed::toggle();
		ledBlue::toggle();
		xpcc::delay_ms(100);
		ledOrange::toggle();
		ledGreen::toggle();
		xpcc::delay_ms(100);
	}
}

// From Joseph Yiu, minor edits by FVH
// hard fault handler in C,
// with stack frame location as input parameter
// called from HardFault_Handler in file xxx.s
// source: http://blog.frankvh.com/2011/12/07/cortex-m3-m4-hard-fault-handler/
extern "C" void
HardFault_Handler_CPP (unsigned int * hardfault_args){
  unsigned int stacked_r0;
  unsigned int stacked_r1;
  unsigned int stacked_r2;
  unsigned int stacked_r3;
  unsigned int stacked_r12;
  unsigned int stacked_lr;
  unsigned int stacked_pc;
  unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
  stacked_r1 = ((unsigned long) hardfault_args[1]);
  stacked_r2 = ((unsigned long) hardfault_args[2]);
  stacked_r3 = ((unsigned long) hardfault_args[3]);

  stacked_r12 = ((unsigned long) hardfault_args[4]);
  stacked_lr = ((unsigned long) hardfault_args[5]);
  stacked_pc = ((unsigned long) hardfault_args[6]);
  stacked_psr = ((unsigned long) hardfault_args[7]);

  for(int i = 0; i < 10; i++){
	  cerr << "\n\n[Hard fault handler - all numbers in hex]\n";
	  cerr << "R0 = " << stacked_r0 << endl;
	  cerr << "R1 = " << stacked_r1 << endl;
	  cerr << "R2 = " << stacked_r2 << endl;
	  cerr << "R3 = " << stacked_r3 << endl;
	  cerr << "R12 = " << stacked_r12 << endl;
	  cerr << "LR [R14] = " << stacked_lr << "  subroutine call return address" << endl;
	  cerr << "PC [R15] = " << stacked_pc << "  program counter" << endl;
	  cerr << "PSR = " <<  stacked_psr << endl;
	  cerr << "BFAR = " << (*((unsigned long *)(0xE000ED38))) << endl;
	  cerr << "CFSR = " <<  (*(( unsigned long *)(0xE000ED28))) << endl;
	  cerr << "HFSR = " << (*(( unsigned long *)(0xE000ED2C))) << endl;
	  cerr << "DFSR = " << (*(( unsigned long *)(0xE000ED30))) << endl;
	  cerr << "AFSR = " << (*(( unsigned long *)(0xE000ED3C))) << endl;
	  //printf ("SCB_SHCSR = %x\n", SCB->SHCSR);
  }
  blink();
}

extern "C" void
NMI_Handler(void){
	for(int i = 0; i < 10; i++){
		cerr << __PRETTY_FUNCTION__ << endl;
	}
	blink();
}

extern "C" void
MemManage_Handler(void){
	for(int i = 0; i < 10; i++){
		cerr << __PRETTY_FUNCTION__ << endl;
	}
	blink();
}

extern "C" void
BusFault_Handler(void){
	for(int i = 0; i < 10; i++){
		cerr << __PRETTY_FUNCTION__ << endl;
	}
	blink();
}

extern "C" void
UsageFault_Handler(void){
	for(int i = 0; i < 10; i++){
		cerr << __PRETTY_FUNCTION__ << endl;
	}
	blink();
}
/*
 * hallSensor.cpp
 *
 *  Created on: Dec 23, 2013
 *      Author: jonas
 */

#include "hallSensor.h"
#include <xpcc/architecture.hpp>



GPIO__INPUT(XFRONT, D, 6);
GPIO__INPUT(XEND, D, 7);
GPIO__INPUT(YFRONT, D, 8);
GPIO__INPUT(YEND, D, 9);

using namespace xpcc::stm32;

template<>
bool HallSensor<ALL>::init(){
	for(int i = 0; i < 2; i++){
		triggered[i] = false;
		//state array will be initialized with real values
	}
	XFRONT::setInput(xpcc::stm32::PULLUP);
	XEND::setInput(xpcc::stm32::PULLUP);
	YFRONT::setInput(xpcc::stm32::PULLUP);
	YEND::setInput(xpcc::stm32::PULLUP);

	HallSensor<X>::setFrontState(XFRONT::read());
	HallSensor<X>::setEndState(XEND::read());
	HallSensor<Y>::setFrontState(YFRONT::read());
	HallSensor<Y>::setEndState(YEND::read());


	coutRaw << "valf " << YFRONT::read() << " vale " << YEND::read() << endl;
	coutRaw << HallSensor<Y>::isAtFront() << " 2-2 " << HallSensor<Y>::isAtEnd() << endl;

	ExtInt::enable(ExtInt::Pin::PD6);
	ExtInt::setMode(ExtInt::Pin::PD6, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PD6);
	ExtInt::enableInterruptVector(ExtInt::Pin::PD6, 6);

	ExtInt::enable(ExtInt::Pin::PD7);
	ExtInt::setMode(ExtInt::Pin::PD7, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PD7);
	ExtInt::enableInterruptVector(ExtInt::Pin::PD7, 6);

	ExtInt::enable(ExtInt::Pin::PD8);
	ExtInt::setMode(ExtInt::Pin::PD8, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PD8);
	ExtInt::enableInterruptVector(ExtInt::Pin::PD8, 6);

	ExtInt::enable(ExtInt::Pin::PD9);
	ExtInt::setMode(ExtInt::Pin::PD9, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PD9);
	ExtInt::enableInterruptVector(ExtInt::Pin::PD9, 6);
	return true;
}

extern "C" void
EXTI9_5_IRQHandler(void) {
	if (xpcc::stm32::ExtInt::getInterruptFlag(ExtInt::Pin::PD6)) {
		ExtInt::resetInterruptFlag(ExtInt::Pin::PD6);
		HallSensor<X>::setFrontState(XFRONT::read());
	}
	else if (xpcc::stm32::ExtInt::getInterruptFlag(ExtInt::Pin::PD7)) {
		ExtInt::resetInterruptFlag(ExtInt::Pin::PD7);
		HallSensor<X>::setEndState(XEND::read());
	}
	else if (xpcc::stm32::ExtInt::getInterruptFlag(ExtInt::Pin::PD8)) {
		ExtInt::resetInterruptFlag(ExtInt::Pin::PD8);
		HallSensor<Y>::setFrontState(YFRONT::read());
		State::setBlue(true);
	}
	else if (xpcc::stm32::ExtInt::getInterruptFlag(ExtInt::Pin::PD9)) {
		ExtInt::resetInterruptFlag(ExtInt::Pin::PD9);
		HallSensor<Y>::setEndState(YEND::read());
		State::setRed(true);
	}

	Motor<X>::setSpeed(0);
	Motor<Y>::setSpeed(0);

}

/*
 * laserInterface.cpp
 *
 *  Created on: Dec 30, 2013
 *      Author: jonas
 *
 *  UART DMA source: http://www.mikrocontroller.net/topic/243265
 *  UART interrupt source: http://eliaselectronics.com/stm32f4-usart-example-with-interrupt/
 */

#pragma GCC push_options
#pragma GCC optimize ("O0")

#include <xpcc/architecture.hpp>

#include "laserInterface.h"
#include "state.h"
#include "atof.h"
#include "../ext/stm32f4xx_lib/CMSIS/Device/ST/STM32F4xx/Include/stm32f4xx.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h"
#include "../ext/stm32f4xx_lib/STM32F4xx_StdPeriph_Driver/inc/misc.h"

//source for dma: http://www.mikrocontroller.net/topic/251293

//==================================
//=== Output ====
//==================================
static unsigned char normalRequest[] = "M1,1\r";//{ 'M', '0', ',', '1', '\r'};
static const int normalRequestLength = 5;
static const int normalRequestAnswerLength = 15; //TODO

static unsigned char* bufferOut = normalRequest;
static int expectedAnswerLength = normalRequestAnswerLength;
static int requestLength = normalRequestLength;

static int lastError = -1;

//==================================
//=== Input ====
//==================================

//==================================
//=== Double buffer ====
//==================================
unsigned char Laser::DoubleBuffer::buf1[LASER_INPUT_BUFFER_SIZE+1];
unsigned char Laser::DoubleBuffer::buf2[LASER_INPUT_BUFFER_SIZE+1] = {'\0'};
unsigned char* Laser::DoubleBuffer::bufInPtr = Laser::DoubleBuffer::buf1;
unsigned char* Laser::DoubleBuffer::bufOutPtr = Laser::DoubleBuffer::buf2;
int Laser::DoubleBuffer::inSize = 0;
int Laser::DoubleBuffer::outSize = 0;

xpcc::stm32::Usart3 uart3(115200);
xpcc::IODeviceWrapper<xpcc::stm32::Usart3> uartWrap3(uart3);
xpcc::IOStream laserOutStream(uartWrap3);

using namespace xpcc::stm32;

//==================================
//=== Functions
//==================================
void USART3_Init(void);
void DMAStream3_Channel4_Init();
void enable_USART3_Interrupts();

bool Laser::init(){
	//uart2.configurePins(xpcc::stm32::USART3::Mapping::REMAP_PA2_PA3);
	enable_USART3_Interrupts();
	USART3_Init();
	DMAStream3_Channel4_Init();
	USART_DMACmd(USART3, USART_DMAReq_Tx, ENABLE);
	return true;
}

int Laser::getLastError(){
	return lastError;
}

void Laser::enableRequests(){
	DMA_Cmd(DMA1_Stream3, ENABLE);
}

int Laser::DoubleBuffer::asInt(){
	return good() ? atoi2(Laser::DoubleBuffer::get()+3, 0) : 9000;
}

int Laser::DoubleBuffer::good(){
	return outSize == expectedAnswerLength && lastError == -1;
}

void USART3_Init(void){
  GPIO_InitTypeDef GPIOC_10_11_InitStructure;
  USART_InitTypeDef USART3_InitStructure;

  //GPIO C 10/11 Init
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

  GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART3);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART3);

  GPIOC_10_11_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIOC_10_11_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIOC_10_11_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
  GPIOC_10_11_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIOC_10_11_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

  GPIO_Init(GPIOC, &GPIOC_10_11_InitStructure);

  //USART 3 Init
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);

  USART3_InitStructure.USART_BaudRate = 115200;
  USART3_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART3_InitStructure.USART_StopBits = USART_StopBits_1;
  USART3_InitStructure.USART_Parity = USART_Parity_No;
  USART3_InitStructure.USART_HardwareFlowControl =
USART_HardwareFlowControl_None;
  USART3_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_Init(USART3, &USART3_InitStructure);
  USART_Cmd(USART3, ENABLE);
}

void DMAStream3_Channel4_Init(void){
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);

  DMA_InitTypeDef DMA_InitStruct;
  DMA_StructInit(&DMA_InitStruct);
  DMA_InitStruct.DMA_Channel = DMA_Channel_4;
  DMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)&(USART3->DR);
  DMA_InitStruct.DMA_Memory0BaseAddr = (uint32_t)bufferOut;
  DMA_InitStruct.DMA_DIR = DMA_DIR_MemoryToPeripheral;
  DMA_InitStruct.DMA_BufferSize = requestLength;
  DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
  DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;
  DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
  DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
  DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;
  DMA_InitStruct.DMA_Priority = DMA_Priority_Medium;
  DMA_InitStruct.DMA_FIFOMode = DMA_FIFOMode_Disable;
  DMA_InitStruct.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
  DMA_InitStruct.DMA_MemoryBurst = DMA_MemoryBurst_Single;
  DMA_InitStruct.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
  DMA_Init(DMA1_Stream3, &DMA_InitStruct);
}

void enable_USART3_Interrupts(){

	/* Here the USART3 receive interrupt is enabled
	 * and the interrupt controller is configured
	 * to jump to the USART3_IRQHandler() function
	 * if the USART3 receive interrupt occurs
	 */
	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); // enable the USART3 receive interrupt

	NVIC_InitTypeDef NVIC_InitStructure; // this is used to configure the NVIC (nested vector interrupt controller)
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;		 // we want to configure the USART3 interrupts
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;// this sets the priority group of the USART3 interrupts
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		 // this sets the subpriority inside the group
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			 // the USART3 interrupts are globally enabled
	NVIC_Init(&NVIC_InitStructure);							 // the properties are passed to the NVIC_Init function which takes care of the low level stuff

	// finally this enables the complete USART3 peripheral
	USART_Cmd(USART3, ENABLE);
}

extern int count;

// this is the interrupt request handler (IRQ) for ALL USART3 interrupts
extern "C" void
USART3_IRQHandler(void){

	// check if the USART3 receive interrupt flag was set
	if( USART_GetITStatus(USART3, USART_IT_RXNE) ){

		char c = USART3->DR;

		Laser::DoubleBuffer::addChar(c);

		if(c == '\r'){
			//do some sanity checks
			int iLast1 = Laser::DoubleBuffer::getInSize()-3; //last char is '\r'

			if(Laser::DoubleBuffer::get()[0] == 'E'
					&& Laser::DoubleBuffer::get()[1] == 'R'){
				lastError = atoi2(Laser::DoubleBuffer::get()+6, 2, -1);
				Laser::DoubleBuffer::reset();
			/*}else if(Laser::DoubleBuffer::get()[iLast1] != 'G'){  //expected: GO
				lastError = 1000;
				iout << Laser::DoubleBuffer::get()[iLast1] << endl;*/
			}else{
				lastError = -1; //no error
				if(Laser::DoubleBuffer::getInSize() == normalRequestAnswerLength){
					Laser::DoubleBuffer::swap();
				}else{
					Laser::DoubleBuffer::reset();
					lastError = 2000+Laser::DoubleBuffer::getInSize();
				}
			}
		}

		if(Laser::DoubleBuffer::getInSize() >= LASER_INPUT_BUFFER_SIZE){
			Laser::DoubleBuffer::reset(); //reset everything
		}

		//USART_ClearITPendingBit(USART3, USART_IT_RXNE); not needed
	}
}

#pragma GCC pop_options

#include <xpcc/architecture.hpp>

#include "control.h"
#include "encoder.h"
#include "motor.h"
#include "hallSensor.h"
#include "project.h"
#include "pcInterface.h"
#include "laserInterface.h"
#include "Trigger.h"
#include "pattern.h"
#include "utils.h"

using namespace xpcc::stm32;

static bool initClock(){
	// use external 8MHz crystal
	if (!Clock::enableHse(Clock::HseConfig::HSE_CRYSTAL)) {
		return false;
	}
	Clock::enablePll(Clock::PllSource::PLL_HSI, 8, 168);
	return Clock::switchToPll();
}


static long long unsigned int step = 0;

void printControlY(){
	coutRaw << Control<Y>::getShallPosition() << " " << Control<Y>::getIsPosition() << " "
			<< Control<Y>::getShallSpeed() << " " << Control<Y>::getIsSpeed() << " "
			<< Control<Y>::getSpeedU() << " " << Control<Y>::getSpeedRealU() << endl;
}

void printControlY2(){
	coutRaw << "pos_shall " << Control<Y>::getShallPosition() << " pos_is " << Control<Y>::getIsPosition() << " v_shall "
			<< Control<Y>::getShallSpeed() << " v_is " << Control<Y>::getIsSpeed() << " v_u "
			<< Control<Y>::getSpeedU() << " errsum " << Control<Y>::getSpeedErrorSum() << endl;
}

void printYStepResponse(){
	coutRaw << step << " " << Control<Y>::getIsSpeed() << endl;
}

void systick(){
	// DEBUG CONTROL LOOPS
	// SPEED CONTROL LOOP
	//coutRaw << step << " " << Control<X>::getShallSpeed() << " " << Control<X>::getIsSpeed() << endl;
	// POSITION CONTROL LOOP
	//coutRaw << step << " " << Control<X>::getShallPosition() << " " << Control<X>::getIsPosition() << endl;
	Control<ALL>::update(false);
	printControlY();
	//printYStepResponse();
	step++;
}

MAIN_FUNCTION{
	bool ok;
	ok = initClock(); //if this fails, we are going to have a bad time

	//--------------------------------------------------------------
	//Init routines
	//--------------------------------------------------------------
	State::init(); //state handling, can visualize init failures via LEDs
	ok = PC::init(); //starts up COM interface to computer
	dout << "COM INIT " << ok << endl;
	ok = Encoder::init();
	dout << "ENCODER INIT " << ok << endl;
	ok = Motor<ALL>::init();
	dout << "MOTOR INIT " << ok << endl;
	ok = HallSensor<ALL>::init();
	dout << "HALLSENSOR INIT " << ok << endl;
	ok = Control<ALL>::init();
	dout << "CONTROL INIT " << ok << endl;
	ok = Laser::init();
	dout << "LASER INTERFACE INIT " << ok << endl;

	//--------------------------------------------------------------
	//go go go
	//--------------------------------------------------------------
	coutRaw << HallSensor<Y>::isAtFront() << " - " << HallSensor<Y>::isAtEnd() << endl;
	SysTickTimer::attachInterrupt(systick);

	Control<ALL>::enablePositionControl(false);
	Control<ALL>::enableSpeedControl(false);
	Utils::calibrateZero();

	//Utils::enableSystick();
	Laser::enableRequests();
	State::set(State::READY);

	Control<ALL>::enableSpeedControl(true);
	Control<ALL>::enablePositionControl(true);

	//Trigger::enable(false);
int i = 0;
	//laser test
	while(1){
		Trigger::sample();
		PC::scanForCommands();
		Trigger::sample();
		Pattern::follow();

		//coutRaw << "my " << Motor<Y>::getFaultStatus() << endl;
		//if(Control<Y>::getIsSpeed() != 0)
			//coutRaw << Control<Y>::getIsSpeed() << endl;
		//coutRaw << "X: " << Control<X>::getIsPosition();
		//coutRaw << " sy "  << Control<Y>::getIsPosition() << " vy " << Control<Y>::getIsSpeed() << endl;
		//coutRaw << " ::: " << Laser::DoubleBuffer::asInt() << " " << Laser::DoubleBuffer::get() << endl;
	}
}
/*
 * motor.cpp
 *
 *  Created on: Nov 24, 2013
 *      Author: jonas
 */

#include "motor.h"
#include <xpcc/architecture.hpp>
#include "project.h"

using namespace xpcc::stm32;

//private namespace
namespace{
GPIO__INPUT(M1_FB, B, 0);
GPIO__INPUT(M2_FB, B, 1);
GPIO__INPUT(M1_FS, B, 2);
GPIO__INPUT(M2_FS, B, 4);

GPIO__OUTPUT(M1_IN1, C, 6); //TIM3 CH1
GPIO__OUTPUT(M1_IN2, C, 7); //TIM3 CH2
GPIO__OUTPUT(M2_IN1, C, 8); //TIM3 CH3
GPIO__OUTPUT(M2_IN2, C, 9); //TIM3 CH4
}

void saturate(int& value){
	if(value > 1200){
		value = 1200;
	}else if(value < -1200){
		value = -1200;
	}
	if(abs(value) < 50){
		value = 0;
	}
}


template<>
void Motor<X>::brake(){
	Timer3::setCompareValue(1, 0);
	Timer3::setCompareValue(2, 0);
}

template<>
void Motor<Y>::brake(){
	Timer3::setCompareValue(3, 0);
	Timer3::setCompareValue(4, 0);
}

template<>
void Motor<ALL>::brake(){
	Motor<X>::brake();
	Motor<Y>::brake();
}

template<>
void Motor<X>::setSpeed(int speed){
	saturate(speed);
	if(speed > 0){
		Timer3::setCompareValue(1, speed);
		Timer3::setCompareValue(2, 0);
	}
	else{
		speed = -speed;
		Timer3::setCompareValue(2, speed);
		Timer3::setCompareValue(1, 0);
	}
}

template<>
void Motor<Y>::setSpeed(int speed){
	saturate(speed);
	if(speed > 0){
		Timer3::setCompareValue(3, speed);
		Timer3::setCompareValue(4, 0);
	}
	else{
		speed = -speed;
		Timer3::setCompareValue(4, speed);
		Timer3::setCompareValue(3, 0);
	}
}

template<>
bool Motor<ALL>::init(){
	//TODO Feedback

	M1_FS::setInput(xpcc::stm32::PULLUP);
	ExtInt::enable(ExtInt::Pin::PB2);
	ExtInt::setMode(ExtInt::Pin::PB2, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PB2);
	ExtInt::enableInterruptVector(ExtInt::Pin::PB2, 15);

	M2_FS::setInput(xpcc::stm32::PULLUP);
	ExtInt::enable(ExtInt::Pin::PB4);
	ExtInt::setMode(ExtInt::Pin::PB4, ExtInt::Mode::RisingFalling);
	ExtInt::enableInterrupt(ExtInt::Pin::PB4);
	ExtInt::enableInterruptVector(ExtInt::Pin::PB4, 15);

	M1_IN1::setAlternateFunction(AF_TIM3, PUSH_PULL);
	M1_IN2::setAlternateFunction(AF_TIM3, PUSH_PULL);
	M2_IN1::setAlternateFunction(AF_TIM3, PUSH_PULL);
	M2_IN2::setAlternateFunction(AF_TIM3, PUSH_PULL);

	Timer3::enable();
	Timer3::setMode(Timer3::UP_COUNTER);

	// 72 MHz / 2 / 1200 = 60kHz
	Timer3::setPrescaler(1);
	Timer3::setOverflow(1200);
	Timer3::configureOutputChannel(1, Timer3::OUTPUT_PWM, 0);
	Timer3::configureOutputChannel(2, Timer3::OUTPUT_PWM, 0);
	Timer3::configureOutputChannel(3, Timer3::OUTPUT_PWM, 0);
	Timer3::configureOutputChannel(4, Timer3::OUTPUT_PWM, 0);
	Timer3::applyAndReset();
	Timer3::start();

	if(!M1_FS::read()){
		//fault state
		State::set(State::MOTOR1_FAULT);
	}

	if(!M2_FS::read()){
		//fault state
		State::set(State::MOTOR2_FAULT);
	}
	return true;
}


template<>
bool Motor<X>::getFaultStatus(){
	return M1_FS::read();
}

template<>
bool Motor<Y>::getFaultStatus(){
	return M2_FS::read();
}

/**
 * Motor 1 fault state handler
 * Connected to PB2
 */
extern "C" void
EXTI2_IRQHandler(void) {
	ExtInt::resetInterruptFlag(ExtInt::Pin::PB2);
	if(!M1_FS::read()){
		//fault state
		State::set(State::MOTOR1_FAULT);
	}
}

/**
 * Motor 2 fault state handler
 * Connected to PB4
 */
extern "C" void
EXTI4_IRQHandler(void) {
	ExtInt::resetInterruptFlag(ExtInt::Pin::PB4);
	if(!M2_FS::read()){
		//fault state
		State::set(State::MOTOR2_FAULT);
	}
}
/*
 * pattern.cpp
 *
 *  Created on: Jan 20, 2014
 *      Author: jonas
 */

#include "pattern.h"

void (*Pattern::func)(void) = 0;
int Pattern::running = 0;

/*
 * pcInterface.cpp
 *
 *  Created on: Dec 30, 2013
 *      Author: jonas
 */

#include "pcInterface.h"
#include "project.h"
#include "atof.h"
#include "control.h"
#include "limits.h"
#include <xpcc/architecture.hpp>

xpcc::stm32::BufferedUsart2 uart(921600, 10);
xpcc::IODeviceWrapper<xpcc::stm32::BufferedUsart2> uartWrap(uart);
xpcc::IOStream coutRaw(uartWrap);

xpcc::IODeviceWrapper<Stream<'P', false> > poutWrap;
xpcc::IOStream pout(poutWrap);

xpcc::IODeviceWrapper<Stream<'M', false> > moutWrap;
xpcc::IOStream mout(moutWrap);

xpcc::IODeviceWrapper<Stream<'D', false> > doutWrap;
xpcc::IOStream dout(doutWrap);

xpcc::IODeviceWrapper<Stream<'E', false> > cerrWrap;
xpcc::IOStream cerr(cerrWrap);

xpcc::IODeviceWrapper<Stream<'I', false> > iWrap;
xpcc::IOStream iout(iWrap);

namespace{
char buffer[256];
int bufPos = 0;

PC::Command CommandTable[] = {
    { "GO X", Handlers::gotoHandler<X> } //goto x
   ,{ "GO Y", Handlers::gotoHandler<Y> } //goto y
   ,{ "SPEX", Handlers::setSpeedHandler<X> } //Speed X [-1,1]
   ,{ "SPEY", Handlers::setSpeedHandler<Y> } //Speed Y [-1,1]
   ,{ "PWMX", Handlers::setPwmHandler<X> } //PWM X [-1200,1200]
   ,{ "PWMY", Handlers::setPwmHandler<Y> } //PWM Y [-1200,1200]
   ,{ "MAXS", Handlers::setMaxSpeedHandler } //sets max speed for patterns [0,1]
   ,{ "EN S", Handlers::enableSystickHandler } //enable systick
   ,{ "ER L", Handlers::getLaserError } //get current laser error, dummy param required
   ,{ "EN T", Handlers::enableTrigger } //enable trigger, param is 0 or 1
   ,{ "BOOT", Handlers::resetHandler } //reset microController, dummy param required
    //Rectangle pattern, parameters: x,y,width,height,sampling resolution;
    //First call demonstrates the size, second call confirms
   ,{ "PAR1", Handlers::rectanglePatternHandler }
   ,{ "PAPA", Handlers::pausePatternHandler } //pauses the current pattern, dummy param required
    //shall be called 5 consecutive times, 4 times for coordinates, 5th call sets sampling resolution
   //,{ "PAR2", Handlers::rectanglePatternHandler2 }
};
}

bool PC::init(){
	uart.configurePins(xpcc::stm32::BufferedUsart2::Mapping::REMAP_PA2_PA3);
	return true;
}

//TODO binary search
PC::Command* PC::getCommand(const char* command){
	int size = sizeof(CommandTable)/sizeof(CommandTable[0]);
	for(int i = 0; i < size; i++){
		int word1 = *(int*)&CommandTable[i].name[0];
		int word2 = *(int*)&command[0];
		if(word1 == word2){
			return &CommandTable[i];
		}
	}
	return 0;
}

void PC::scanForCommands(){
	uint8_t c;
	if(uart.read(c)){
		if(c != '\n'){
			buffer[bufPos++] = char(c);
		}else{
			buffer[bufPos] = 0;
			if(bufPos < 5){
				dout << "Ignoring " << buffer;
				bufPos = 0;
				return;
			}
			Command* cmd = getCommand(buffer);
			if(!cmd){
				cerr << "cannot interpret " << buffer << endl;
				bufPos = 0;
				return;
			}
			bool ok = cmd->handler(&buffer[5], bufPos-5);
			if(ok){
				iout << "OK: " << buffer << endl;
			}
			bufPos = 0;
		}
	}
}

void PC::registerCommandHandler(const char* command, bool (*handler)(const char*, int)){
	Command* cmd = PC::getCommand(command);
	if(!cmd){
		cerr << "Error tried to register handler for unknown command: " << command << endl;
		return;
	}
	cmd->handler = handler;
}


bool PC::defaultHandler(const char* command, int length){
	cerr << "Unhandled command: " << command << endl;
	return false;
}
/*
 * rectangle.cpp
 *
 *  Created on: Feb 1, 2014
 *      Author: jonas
 */

#include "rectangle.h"
#include "transform.h"
#include "control.h"

int Rectangle::x;
int Rectangle::y;
int Rectangle::width;
int Rectangle::height;

struct Point{
	int x,y;
};

static Point points[5];
static int pointsIndex = 0;

static bool reachedPoint(){
	return abs(Control<X>::getIsPosition() - points[pointsIndex].x) < 30 &&
			abs(Control<Y>::getIsPosition() - points[pointsIndex].y) < 30;
}


void Rectangle::configure(int x, int y, int width, int height){
	Rectangle::x = Transform::mmToEncoder(x);
	Rectangle::y = Transform::mmToEncoder(y);
	Rectangle::width = Transform::mmToEncoder(width);
	Rectangle::height = Transform::mmToEncoder(height);

	/**
	 * 2-----3
	 * |     |
	 * |     |
	 * 1-----4
	 */

	points[0].x = Rectangle::x;
	points[0].y = Rectangle::y;
	points[1].x = points[0].x;
	points[1].y = points[0].x + Rectangle::height;
	points[2].x = points[1].x + Rectangle::width;
	points[2].y = points[1].y;
	points[3].x = points[2].x;
	points[3].y = points[0].y;
	points[4].x = points[0].x;
	points[4].y = points[0].y;
	pointsIndex = 0;

	Control<X>::setShallPosition(points[0].x);
	Control<Y>::setShallPosition(points[0].y);
}

void Rectangle::sample(){
	if(reachedPoint()){
		pointsIndex++;
		if(pointsIndex > 4){
			Pattern::done();
			return;
		}
		Control<X>::setShallPosition(points[pointsIndex].x);
		Control<Y>::setShallPosition(points[pointsIndex].y);
	}

}

/*
 * RectangleZigZag.cpp
 *
 *  Created on: Jan 18, 2014
 *      Author: jonas
 */

#include "RectangleZigZag.h"

/**
 * ^
 * |
 * |
 * |
 * |
 * y x------>
 *
 *
 * ^-> ->
 * | | | |
 * | | | |
 * | | | |
 * | | | |
 * | | | |
 * | -> ->
 */

namespace{

inline int nextX(){
	return Control<X>::getShallPosition();
}

inline int nextY(){
	return Control<Y>::getShallPosition();
}
bool approachingX;
int yDirection;
}

//TODO threshold

bool RectangleZigZag::isAtEnd(){
	return abs(nextX()-stopX) < 100 && abs(nextY()-stopY) < 100;
}

static inline bool reachedPointX(int x){
	return abs(x-nextX()) < 100;
}

static inline bool reachedPointY(int y){
	return abs(y-nextY()) < 100;
}

void RectangleZigZag::sample(){
	if(isAtEnd() && Pattern::isRunning()){
		Pattern::done();
	}

	int x = Control<X>::getIsPosition();
	int y = Control<Y>::getIsPosition();

	if(approachingX && reachedPointX(x)){
		int nextPosY = yDirection == 1 ? stopY : startY;
		yDirection *= -1;
		Control<Y>::setShallPosition(nextPosY);
		approachingX = false;
	}else if(!approachingX && reachedPointY(y)){
		Control<X>::setShallPosition(nextX()+samplingResolution);
		approachingX = true;
	}

	//sit back and let control do its job
}

void RectangleZigZag::configure(int x, int y, int width, int height, int samplingResolution){
		RectangleZigZag::startX = Transform::mmToEncoder(x);
		RectangleZigZag::startY = Transform::mmToEncoder(y);
		RectangleZigZag::stopX = startX + Transform::mmToEncoder(width);
		RectangleZigZag::stopY = startY + Transform::mmToEncoder(height);
		RectangleZigZag::samplingResolution = samplingResolution;

		Control<X>::setShallPosition(startX);
		Control<Y>::setShallPosition(startY);
		approachingX = false;
		yDirection = 1;
	}
/*
 * state.cpp
 *
 *  Created on: Dec 30, 2013
 *      Author: jonas
 */

#include "state.h"
#include "project.h"
#include "pcInterface.h"

#include <xpcc/architecture.hpp>

using namespace xpcc::stm32;

GPIO__OUTPUT(ledRed, D, 14);
GPIO__OUTPUT(ledBlue, D, 15);
GPIO__OUTPUT(ledOrange, D, 13);
GPIO__OUTPUT(ledGreen, D, 12);

int State::currentState;


void disableAllLeds(){

	//disable timers
	Timer1::pause();
	Timer6::pause();
	Timer7::pause();

	ledRed::set(false);
	ledBlue::set(false);
	ledOrange::set(false);
	ledGreen::set(false);
}

void State::init(){
	ledRed::setOutput(xpcc::stm32::PUSH_PULL);
	ledBlue::setOutput(xpcc::stm32::PUSH_PULL);
	ledOrange::setOutput(xpcc::stm32::PUSH_PULL);
	ledGreen::setOutput(xpcc::stm32::PUSH_PULL);

	//configure timers:
	//timer1 -> red led -> errors
	Timer1::enable();
	Timer1::setMode(Timer3::UP_COUNTER);
	Timer1::enableInterruptVector(GeneralPurposeTimer::Interrupt::INTERRUPT_UPDATE, true, 15);
	Timer1::enableInterrupt(Timer1::INTERRUPT_UPDATE);
	Timer1::setPeriod(300000);	// 300 ms

	//timer6 -> blue led -> executing rectangle scan
	Timer6::enable();
	Timer6::setMode(Timer6::UP_COUNTER);
	Timer6::enableInterruptVector(true, 15);
	Timer6::enableInterrupt(Timer6::INTERRUPT_UPDATE);
	Timer6::setPeriod(1000000);	// 1000 ms

	//timer7 -> orange led -> velocity controlled
	Timer7::enable();
	Timer7::setMode(Timer7::UP_COUNTER);
	Timer7::enableInterruptVector(true, 15);
	Timer7::enableInterrupt(Timer7::INTERRUPT_UPDATE);
	Timer7::setPeriod(200000);	// 700 ms

	State::set(State::INITIALIZING);
}

void State::set(int newState){
	currentState = newState;
	disableAllLeds();

	dout << "going to state " << newState << endl;
	switch(newState){
	case State::INITIALIZING:
		ledOrange::set(true);
		ledRed::set(true);
		break;
	case State::READY:
		ledGreen::set(true);
		break;
	case State::SCANNING_RECTANGLE:
		Timer6::start();
		break;
	case State::MOTOR1_FAULT:
	case State::MOTOR2_FAULT:
	case State::PC_INIT_FAIL:
		Timer1::start();
		break;
	}
}

void State::setSecondaryState(int state, bool set){
	//dout << "motor limit " << set << endl;
	switch(state){
	case State::MOTOR_LIMITED:
		if(set){
			Timer7::start();
		}else{
			Timer7::pause();
			setOrange(false);
		}
		break;
	}
}

void State::setRed(bool on){
	ledRed::set(on);
}

void State::setBlue(bool on){
	ledBlue::set(on);
}

void State::setOrange(bool on){
	ledOrange::set(on);
}

void State::setGreen(bool on){
	ledGreen::set(on);
}

extern "C" void
TIM1_UP_TIM10_IRQHandler(void){
	Timer1::resetInterruptFlags(Timer1::FLAG_UPDATE);
	ledRed::toggle();
}

extern "C" void
TIM6_DAC_IRQHandler(void){
	Timer6::resetInterruptFlags(Timer6::FLAG_UPDATE);
	ledBlue::toggle();
}

extern "C" void
TIM7_IRQHandler(void){
	Timer7::resetInterruptFlags(Timer7::FLAG_UPDATE);
	ledOrange::toggle();
}


/*
 * Trigger.cpp
 *
 *  Created on: Jan 16, 2014
 *      Author: jonas
 */

#include "Trigger.h"
#include "laserInterface.h"
#include "control.h"

namespace{
int thresholdX = 10;
int thresholdY = 10;
int lastXPos = 0;
int lastYPos = 0;
bool enabled = true;
}

void Trigger::sample(){
	if(!enabled)
		return;

	int xnow = Control<X>::getIsPosition();
	int ynow = Control<Y>::getIsPosition();

	if(abs(xnow - lastXPos) >= thresholdX ||
	   abs(ynow - lastYPos) >= thresholdY){
		//send output
		lastXPos = xnow;
		lastYPos = ynow;

		mout << "M," << xnow << "," << ynow << ",";
		if(Laser::DoubleBuffer::good()){
			mout << Laser::DoubleBuffer::get() << endl;
		}else{
			mout << INVALID_MEASUREMENT_STRING << endl;
		}
	}

}

void Trigger::enable(bool enable){
	enabled = enable;
}
/*
 * utils.cpp
 *
 *  Created on: Feb 1, 2014
 *      Author: jonas
 */

#include "utils.h"
#include "project.h"
#include <xpcc/math/filter/pid.hpp>
#include <xpcc/architecture.hpp>
#include "control.h"
#include "encoder.h"

void Utils::enableSystick(){
	#if CONTROL_FREQUENCY == 1000
		xpcc::stm32::SysTickTimer::enable();
	#elif CONTROL_FREQUENCY == 10000
		xpcc::stm32::SysTickTimer::enable((F_CPU / 10000) - 1);
	#else
	#error bad control frequency
	#endif
}

void Utils::disableSystick(){
	xpcc::stm32::SysTickTimer::disable();
}

void Utils::startLoggingControl(){
	xpcc::Pid<float,1>::Parameter v_param = Control<Y>::getVPidParams();
	xpcc::Pid<float,1>::Parameter pos_param = Control<Y>::getPosPidParams();
	coutRaw << "# Y-axis" << endl;
	coutRaw << "#V_PID: "
			<< "  P: " << v_param.kp
			<< "  I: " << v_param.ki
			<< "  D: " << v_param.kd
			<< endl;
	coutRaw << "#Pos_PID: "
			<< "  P: " << pos_param.kp
			<< "  I: " << pos_param.ki
			<< "  D: " << pos_param.kd
			<< endl;
	coutRaw << "w_x x w_v v v_u v_ureal" << endl;
	Utils::enableSystick();
	xpcc::delay_ms(50);
}

template<Axis axis>
void driveToZero(){
	//sensors have pull ups
	if(HallSensor<axis>::getFrontState() == 1){
		return;
	}
	Motor<axis>::setSpeed(-1200);
	while(HallSensor<axis>::getFrontState() == 1){
		;;
	}
	Motor<axis>::setSpeed(0);
}

void Utils::calibrateZero(){
	driveToZero<X>();
	//driveToZero<Y>();
	Encoder::zero();
}
